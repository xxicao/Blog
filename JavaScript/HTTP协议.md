
## HTTP协议
HTTP（HyperText Transfer Protocol，超文本传输协议）是不保存状态的协议，既无状态协议，协议本身对于请求或响应之间的通信状态不进行保存，因此连接双方不能知晓对方当前的身份和状态。
这也是Cookie技术产生的重要原因之一：客户端的状态管理。浏览器会根据从服务器端发送的响应报文内 Set-Cookie 首部字段信息自动保持 Cookie。而每次客户端发送 HTTP 请求，都会在请求报文中携带 Cookie，作为服务端识别客户端身份状态的标识。
### TCP/IP 协议
TCP/IP 协议族是 Internet 最基本的协议，HTTP 协议是它的一个子集。TCP/IP 协议族按层次分为以下四层：
- 应用层：TCP/IP 协议族内预存了各类通用的应用服务协议：如 FTP 协议、DNS 服务、HTTP 协议
- 传输层：对接上层应用层，提供处于网络连接中两台计算机之间的数据传输所使用的协议，有两个性质不同的协议：TCP（有连接，全双工） 和 UDP（无连接）
- 网络层：网络层规定了数据通过怎样的传输路线到达对方计算机传送给对方（IP 协议等）。
- 链路层：用来处理连接网络的硬件部分，硬件上的范畴均在链路层的作用范围之内。

##### 发送端在层与层之间传输HTTP数据时，每经过一层时会被打上一个该层所属的首部信息。反之，接收端在层与层之间传输数据时，每经过一层时会把对应的首部信息去除，最后得到发送的HTTP数据。

### HTTP协议发展历程
#### HTTP/1.0 
HTTP/1.0 版本（称为串行连接或**短连接**）中每次HTTP通信后都要断开 TCP 连接，所以每个新的HTTP请求都需要建立一个新的连接。

#### HTTP/1.1
HTTP/1.1 实现并默认了所有连接都是**持久连接**，这样客户端发起多个 HTTP 请求时就减少了 TCP 握手造成的网络资源和通信时间的浪费。但是持久连接采用阻塞模式，下次请求必须等到上次响应返回后才能发起，如果上次的请求还没返回响应内容，下次请求就只能等着（就是常说的线头阻塞）。

#### HTTP/2.0
1. 多路复用： 在一个 TCP 连接中可以存在多条流，也就是可以发送多个请求，服务端则可以通过帧中的标识知道该帧属于哪个流（即请求），通过重新排序还原请求，极大增加了服务器处理并发的上限。
HTTP/1.1 是基于文本分割解析的协议,没有序号,如果多路复用会导致顺序错乱,http2 则用帧的方式,等于切成一块块,每一块都有对应的序号,所以可以实现多路复用。
2. 头部压缩：HTTP/2.0使用 encoder 来减少需要传输的头部大小，通讯双方各自 cache 一份头部 fields 表，既避免了重复头部的传输，又减小了需要传输的大小，
3. 服务端推送：把客户端所需要的 css/js/img 资源伴随着 index.html 一起发送到客户端，省去了客户端重复请求的步骤

#### HTTP/3.0
1. 避免包阻塞：在基于 UDP 的 QUIC 协议中，不同的流之间的数据传输真正实现了相互独立互不干扰，某个流的数据包在出问题需要重传时，并不会对其他流的数据包传输产生影响。
2. 快速重启会话：QUIC 协议使用特有的UUID来标记每一次连接，在网络环境（ip）发生变化的时候，只要 UUID 不变，就能不需要握手，继续传输数据

### HTTP与HTTPS区别：
- 1、HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在 **SSL/TLS** 之上，SSL/TLS（加密技术）运行在TCP之上，**所有传输的内容都经过加密**的。
- 2、HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
- 3、http的连接很简单，是无状态的；HTTPS协议是由HTTP+SSL协议构建的可进行加密传输、身份认证的网络协议，可以有效的防止运营商劫持，解决了防劫持的一个大问题，比http协议安全。

### GET和POST区别
GET产生一个TCP数据包；POST产生两个TCP数据包。
对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；
而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。
1. Get 请求能缓存，Post 不能
2. Post 相对 Get 安全一点点，因为Get 请求都包含在 URL 里， （当然你想写到 body 里也是可以的），且会被浏览器保存历史纪录。Post 不会，但是在抓包的情况下都是一样的。 
3. URL有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的 
4. Post 支持更多的编码类型且不对数据类型限制

用GET替换POST来优化网站性能可行性：
在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次

### 双向通信
WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。
WebSocket是HTML5提出的一种客户端和服务端通讯的全双工协议，由客户端发起请求，建立连接之后不仅客户端可以主动向服务端发送请求，服务端可以主动向客户端推送信息。

#### 特点：
- （1）建立在 TCP 协议之上，服务器端的实现比较容易。
- （2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。
- （3）数据格式比较轻量，性能开销小，通信高效。
- （4）可以发送文本，也可以发送二进制数据。
- （5）没有同源限制，客户端可以与任意服务器通信。
- （6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。

使用示例：
```javascript
var ws = new WebSocket("wss://echo.websocket.org");

ws.onopen = function(evt) { 
  console.log("Connection open ..."); 
  ws.send("Hello WebSockets!");
};

ws.onmessage = function(evt) {
  console.log( "Received Message: " + evt.data);
  ws.close();
};

ws.onclose = function(evt) {
  console.log("Connection closed.");
}; 
```
#### 常用API
客户端的 API:
- webSocket.readyState（readyState属性返回实例对象的当前状态0-3）
- webSocket.onopen（指定连接成功后的回调函数）
- webSocket.onclose（指定连接关闭后的回调函数）
- webSocket.onmessage（指定收到服务器数据后的回调函数）
- webSocket.send（用于向服务器发送数据）
- webSocket.onerror（用于指定报错时的回调函数）
- webSocket.bufferedAmount（用来判断二进制数据发送是否结束）



#### 状态码
[应该了解的常见状态码](https://github.com/xxicao/Blog/blob/master/JavaScript/状态码.md) 

#### Http缓存
[应该了解的强缓存和协商缓存](https://github.com/xxicao/Blog/blob/master/JavaScript/http缓存.md) 


