# 作用域、作用域链
作用域、作用域链与原型对象、原型链的原理类似，均是向上查找的过程。

### 作用域
变量与函数的可访问范围，控制着变量及函数的可见性与生命周期，JS 的作用域是通过函数来定义的，在一个函数中定义的变量只对这个函数内部可见，称为函数（局部）作用域。

#### 注意：JS 采用的是词法作用域(静态作用域)，JS 的函数运行在他们被定义的作用域中，而不是他们被执行的作用域。

#### 创建局部作用域
利用利用IIFE（立即执行匿名函数）创建局部作用域：通过 () 、 && 、逗号等操作符和 `! , + , - ，=`等一元操作符将函数转化为表达式，后面加上括号()，该表达式会立即执行，即函数立即执行。

### 作用域链
作用域链是一个向上查找的过程，用以检索上下文代码中出现的标识符（变量名称，参数，函数声明）。  
当访问一个变量时，首先会查找当前作用域内是否有该变量声明，如果没有就会向上一级作用域查找，直到全局作用域，如果全局也没有找到就会报错`ReferenceError: a is not defined`。

### 执行上下文
执行上下文是 js 代码执行的环境，当 js 执行一段可执行代码时，会创建对应的执行上下文，包含 this ，作用域链，变量对象。

##### 建立执行上下文步骤
1. 初始化作用域链（函数定义时就发生）。
2. 创建变量对象 VO （创建 arguments ，扫描函数声明，扫描变量声明，活动对象AO放入作用域链顶端）。
3. 求 this ，初始化变量和函数引用（发生在函数执行时，形参可以在函数内被覆盖）。

##### 变量对象VO组成
1. arguments 对象（函数实参）。 
2. 当前执行上下文的函数声明，会替换已有变量对象包括 arguments 。
3. 变量声明，不会替换形参和函数  
- **注意：2、3的是否替换，指创建建立上下文阶段或没有执行赋值表达式之前**

##### 活动对象AO：未进入执行阶段之前，变量对象(VO)中的属性都不能访问！但是进入执行阶段之后，变量对象(VO)转变为了活动对象(AO)，里面的属性都能被访问了，然后开始进行执行阶段的操作。它们其实都是同一个对象，只是处于执行上下文的不同生命周期。

### 执行栈
执行栈认为是一个存储函数调用的栈结构，它遵从先进后出的原则，可以理解为调用一个函数时，如果函数内部再调用另外一个函数，会先执行后进入执行栈的这个内部函数。  

##### 执行过程
- 首次运行JavaScript代码的时候,会创建一个全局执行的上下文并 unshift 到当前的执行栈中。（执行栈可以理解为一个数组，用来存储执行上下文）
- 每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并  unshift 当前执行栈的栈顶。
- 当栈顶的函数运行完成后，其对应的函数执行上下文将会从执行栈中 shift 出，上下文的控制权将移动到当前执行栈的下一个执行上下文。

### This
this 指的是当前正在执行或调用该函数的对象的值。this 值的变化取决于我们使用它的上下文和我们在哪里使用它。  
浏览器环境全局作用域下 this 是指向 Window 对象，**注意区分是否严格模式（严格模式下禁止 this 指向全局对象，部分 window 指向是变成 undefined ）**。  
##### Reference 类型
只存在于规范里的抽象类型，描述语言的底层行为逻辑才存在的，由base（属性所在的对象或者就是 EnvironmentRecord）、name、strict三个属性组成。  

#### ECMAScript 规范解读 this ：
1. 判断调用函数时括号 () 左侧的表达式（ MemberExpression ）的返回的结果是不是一个 Reference 类型。
2. 如果内部有调用 GetValue ，调用后返回的将是具体的值，而不是一个 Reference 类型。
2. 如果是 Reference 类型，进一步判断 base 属性的值，如果是一个对象，结果返回该对象 ，如果是 Environment Record，返回 undefined ，this 指向这个结果。
3. 如果不是 Reference 类型，this 的值为 undefined，非严格模式下隐式转换为全局对象

需要彻底了解This指向问题，还是需要从规范中找到一些解答，下面的例子可以体现：
```javascript
var value = 1;
var foo = {
  value: 2,
  bar: function () {
    return this.value;
  }
}
// 因为使用了 GetValue，所以返回的不是 Reference 类型，this 为 undefined
// 此时若按照经验判断的话(false || foo.bar)表达式返回的是 foo.bar ，this应该指向 foo 对象，这是错误的
console.log((false || foo.bar)()); // 1
```

#### 实际开发的 this 场景：
- 作为对象调用时，指向该对象 `obj.b(); // 指向obj`。
- 作为函数直接调用, `var b = obj.a; b(); // 指向全局window`，`test(); // 指向全局window`。
- 作为构造函数调用， `var b = new Fun(); // this指向新实例对象`。
- 使用 call 与 apply 调用， `obj.b.apply(object, []); // this指向当前的object`。
- 事件监听函数中的 this 指向被绑定的 dom 元素，注意需要动态绑定 this ，不能使用箭头函数。
- 箭头函数比较特殊，没有自己的 this ，它使用封闭执行上下文(函数执行上下文或是 global )的 this 值。
- HTML 标签的属性中是可能写 JS 的，这种情况下 this 指代该 HTML 元素。
- 计时器回调函数中的 this 指向 window，相当于函数直接调用。注意如果回调函数是箭头函数的话要另外区分封闭执行上下文。


### 改变 this 指向
[你该了解的Call、Apply、Bind知识](https://github.com/xxicao/Blog/edit/master/JavaScript/Call、Apply、Bind.md)

