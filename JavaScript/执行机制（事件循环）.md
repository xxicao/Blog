## 事件循环				
了解事件循环之前需要先对浏览器的进程与线程有所了解

#### 浏览器进程（4个）
- 主进程（负责浏览器界面的显示与交互。各个页面的管理,创建和销毁其他进程。网络的资源管理、下载等）
- 第三方插件进程（浏览器插件相关）
- GPU进程（用于3D绘制）
- 渲染进程（控制页面渲染与事件循环）

#### 渲染进程包含的线程（5个）
- JS引擎线程
- 定时器触发线程
- 事件触发线程
- GUI渲染线程
- 异步HTTP请求线程

#### 异步执行的运行机制：
1. 所有任务都在主线程（JS引擎线程，也称 JS 内核如V8引擎）上执行，形成一个执行栈（用来存储函数调用的一个栈结构）。
2. 主线程之外，还存在一个"任务队列"（分为宏任务和微任务），只要异步任务（计时器，事件监听，异步请求）有了运行结果，事件触发线程就在"任务队列"之中放置一个事件。
3. 一旦"执行栈"中的所有同步任务执行完毕，就会读取"任务队列"。于是最先进入队列的宏任务（最先的宏任务为script代码），结束等待状态，进入执行栈并开始执行。
4. 一旦"执行栈"执行完这次宏任务，就会检查是否存在微任务，如果存在则不停的执行，直至清空微任务队列。
5. 更新渲染(每一次事件循环，浏览器都可能会去render)。
6. 重复345步骤

#### 任务队列
任务队列分为宏任务（macrotask）队列 与 微任务（microtask）队列，**注册时会依次进入自身对应的队列中**，然后等待 Event Loop 将它们依次压入执行栈中执行。

#### 宏任务：
script(整体代码)、setTimeout、setInterval、setImmediate(高版本 IE 和 Edge)、I/O、postMessage、MessageChannel

- setImmediate：该方法用来把一些需要长时间运行的操作放在一个回调函数里，在浏览器完成后面的其他语句后，就立刻执行这个回调函数。
- MessageChannel：允许我们创建一个新的消息通道，并通过它的两个MessagePort 属性发送数据，通常与postMessage结合使用。


#### 微任务：
process.nextTick(Node.js环境）、Promise.then、MutaionObserver

- process.nextTick()： 在 JavaScript 堆栈上的当前操作运行完成之后以及允许事件循环继续之前，此队列会被完全耗尽。
- MutaionObserver：该构造函数用于用于实例化一个新的 MutaionObserver ，同时指定一个触发 DOM 变动时的回调函数。

#### 与node事件循环差别
浏览器环境下，microtask的任务队列是每个macrotask执行完之后执行。
而在Node.js中，microtask会在事件循环的各个阶段（有6个阶段）之间执行，也就是一个阶段执行完毕，就会去执行microtask队列的任务。
